---
layout: "post"
title: "Malware analysis using python"
categories: [Malware analysis, Python, Cybersecurity]
tags: [Malware analysis, Python, Cybersecurity]
date: "2022-07-05 07:43"
---
There was a nice writeup by [Thomas Roccia at Medium](https://blog.securitybreak.io/10-python-libraries-for-malware-analysis-and-reverse-engineering-622751e6ebd0) listing 10 python libraries for malware analysis and reverse engineering.

[PE-file](https://github.com/erocarrera/pefile) can parse "Portable Executable" format files.

`pip instal pefile`

``` python
import pefile

exefile = calc.exe
exe = pefile.PE(exefile)
print(exe)
```

[Lief](https://lief-project.github.io/) is another Portable Executable parser, also Mach-O and ELF files.

`pip install lief`

``` python
import lief
# ELF
elfbin = lief.parse("/usr/bin/ls")
print(elfbin)

# PE
pebin = lief.parse("calc.exe")
print(pebin)
```

[Capstone](https://www.capstone-engine.org/) is a lightweight multi-platform, multi-architecture disassembly framework.

`pip install capstone`

``` python
from capstone import *

exefile = "calc.exe"
exe = pefile.PE(exefile)

entry_point = exe.OPTIONAL_HEADER.AddressOfEntryPoint
data = exe.get_memory_mapped_image()[entry_point:]
cs = Cs(CS_ARCH_X86, CS_MODE_32)
rdbin = cs.disams(data, 0x1000)

for i in rdbin:
    print("0x%x:\t%s\t%s" %(i.memory, i.mnemonic, i.op_str))
```

[Unicorn](https://www.unicorn-engine.org) Is a lightweight multi-platform, multi-architecture CPU emulator framework.

`pip install unicorn`

```python
from unicorn import *
from unicorn.x86_const import *

# code to be emulated
X86_CODE32 = b"\x41\x4a" # INC ecx; DEC edx

# memory address where emulation starts
ADDRESS = 0x1000000

print("Emulate i386 code")
try:
    " Initialize emulator in X86-32bit mode
    mu = Uc(UC_ARCH_X86, UC_MODE_32)

    # map 2 MB of memory for this emulation
    mu.mem_map(ADDRESS, 2 * 1024 * 1024)

    # write machine code to be emulated to memory
    mu.mem_write(ADDRESS, X86_CODE32)

    # initialize machine registers
    mu.reg_write(UC_X86_REG_ECX, 0x1234)
    mu.reg_write(UC_X86_REG_EDX, 0x7890)

    # emulate code in infinite time & unlimited instructions
    mu.emu_start(ADDRESS, ADDRESS + len(X86_CODE32))

    # print out some registers
    print("Emulation dune. Below is the CPU context")

    r_ecx = mu.reg_read(UC_X86_REG_ECX)
    r_edx = mu.reg_read(UC_X86_REG_EDX)
    print(">>> ECX = 0x%x" %r_ecx)
    print(">>> EDX = 0x%x" %r_edx)

except UcError as e:
    print("ERROR: %s" % e)
```

[Frida](https://github.com/frida/frida-python) is a dynamic binary instrumentation framework capable of extract useful information such as IP address, registry key, mutex and more.

`pip install frida`

```python
from __future__ import print_function
import frida
import sys
import psutil

def checkIfProcessRunning(processName):
    '''
    Check if there is any running process that contains the given processName.
    '''
    # Iterate over all the running processes
    for proc in psutil.process_iter():
        try:
            # Check if process name contains the given name string.
            if processName.lower() in proc.name().lower():
                return True
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.Zombie.Process):
            pass
    return False;

def on_message(message, data):
    print(message)

def main(proc):
    if checkIfProcessRunning(proc):
        print('[+] Process %s is running!' % proc)
        session = frida.attach(proc)

    else:
        print('[!] Process %s was not running!' % proc)
        print('[+] Running process %s!' % proc)
        session = frida.spawn(proc)
        session = frida.attach(proc)

    '''print(type(session))'''
    script = session.create_script("""

                        var Mutex_addr = Module.findExportByName("kernel32.dll", "CreateMutexA")
                        console.log('[+] CreateMutex addr: ' + Mutex_addr);
                        Interceptor.attatch(Mutex_addr,
                        {
                            onEnter: function (args)
                            {
                                console.log("[+] Entering to createMutex")
                                console.log('[+] lpName: ' + Memory.readUtf8String(args[2]));
                            },
                            onLeave: function (retval)
                            {

                            }
                        });

                    """)
    script.on('message', on_message)
    script.load()
    try:
        frida.resume(proc)
    except:
        pass
    sys.stdin.read()

if __name__ == "__main__":

    try:
        target_process = int(sys.argv[1])
    except ValueError:
        target_process = "calc.exe"

    main(target_process)
```

[Ctypes](https://docs.python.org/3/library/ctypes.html) allows, from a Python program, to call functions and procedures located in a compiled library, generally in C (.dll with Windows and .so with Linux).

`pip install ctypes`

```python
import sys
from ctypes import *

WORD = c_ushort
DWORD = c_ulong
LPBYTE = POINTER(c_ubyte)
LPTSTR = POINTER(c_char)
HABDLE = c_void_p

# Specifies the window station, desktop, standard handles, and appearance
# of the main window for a process at creation time.
class STARTUPINFO(Structure):
    _fields_ = [
        ('cb', DWORD),
        ('lpReserved', LPTSTR),
        ('lpDesktop', LPTSTR),
        ('lpTitle', LPTSTR),
        ('dwX', DWORD),
        ('dwY', DWORD),
        ('dwXSize', DWORD),
        ('dwYSize', DWORD),
        ('dwXCountChars', DWORD),
        ('dwYCountChars', DWORD),
        ('dwFillAttribute', DWORD),
        ('dwFlags', DWORD),
        ('wShowWindow', WORD),
        ('cbReserved2', WORD),
        ('lpReserved2', LPBYTE),
        ('hStdInput', HANDLE),
        ('hStdOutput', HANDLE),
        ('hStdError', HANDLE),
    ]

# Contains information about a newly created process and its primary thread
class PROCESS_INFORMATION(Structure):
    _fields_ = [
        ('hProcess', HANDLE)
        ('hThread', HANDLE)
        ('dwProcessId', DWORD)
        ('dwThreadId', DWORD)
    ]

# Process to create
exe = "C:\\Windows\\System32\\calc.exe"

# Import the kernel32 lib
kernel32 = windll.kernel32

# Creation flag
CREATE_NEW_CONSOLE = 0x00000010
CREATE_SUSPENDED = 0x00000004
creation_flags = CREATE_NEW_CONSOLE | CREATE_SUSPENDED

startupinfo = STARTUPINFO()
processinfo = PROCESS_INFORMATION()
startupinfo.cb = sizeof(startupinfo)

try:
    kernel32.CreatePRocessA(None, exe, None, None, None, creation_flags, None, None)
byref(startupinfo), byref(processinfo)
    print("Process started as PID: {}".format(processinfo.dwProcessId))
    kernel32.CloseHandle(processinfo.hProcess)
    kernel32.CloseHandle(processinfo.hThread)
except Exception as e:
    print(e)
    kernel32.GetLastError()
```

[Yara-Python](https://github.com/VirusTotal/yara-python) is a python library allows using Yara in your scripts with your own set of rules.

`pip install yara-python`

```python
import yara

rule = yara.compile(source=
            'rule UNPROTECT_disable_process {\r\n
                    meta:\r\n\tauthor = "Thomas Roccia | @fr0gger_"\r\n\t
                        description = "Disable blacklisted processes"\r\n
                    strings:\r\n
                        $api1 = "CreateToolhelp32Snapshot" nocase\r\n
                        $api2 = "Process32First" nocase\r\n
                        $api3 = "Process32Next" nocase\r\n
                        $api4 = "TerminateProcess" nocase\r\n
                        $api5 = "NtGetNextProcess" nocase\r\n
                        $p1 = "taskkill.exe" nocase\r\n
                        $p2 = "tskill.exe" nocase\r\n
                    condition:\r\n
                        uint32(uint32(0x3C)) == 0x4550 and 2 of ($api*) or any of ($p*) \r\n}')

filename = "killprocess.exe"

matches = rule.match(filename)

if matches:
    print(matches)
```
[Struct](https://docs.python.org/3/library/struct.html) used to convert native Python data types such as strings and numbers to a byte string and vice versa.

**Byte Order, Size and Alignment**
|Character|Byte order|Size|Alignment|
|:-|:-|:-|:-|
|@|native|native|native|
|=|native|standard|none|
|<|little-endian|standard|none|
|>|big-endian|standard|none|
|!|network (= big endian)|standard|none|

**Format Characters**
|Format|C Type|Python type|Standard size|Notes|
|:-|:-|:-|:-|:-|
|x|pad byte|no value|||
|c|char|bytes of length 1|1||
|b|signed char|integer|1|(1),(2)|
|B|unsigned char|integer|1|(2)|
|?|_Bool|bool|1|(1)|
|h|short|integer|2|(2)|
|H|unsigned short|integer|2|(2)|
|i|int|integer|4|(2)|
|I|unsigned int|integer|4|(2)|
|l|long|integer|4|(2)|
|L|unsigned long|integer|4|(2)|
|q|long long|integer|8|(2)|
|Q|unsigned long long|integer|8|(2)|
|n|ssize_t|integer||(3)|
|N|size_t|integer||(3)|
|e|(6)|float|2|(4)|
|f|float|float|4|(4)|
|d|double|float|8|(4)|
|s|char[]|bytes|||
|p|char[]|bytes|||
|P|void*|integer||(5)|

```python
import struct

# 4s -> four char to pack
# i -> integer
# f -> float
# l -> long

pack = struct.pack('4s i f l', b'test', 5, 3.14, 255)
print(pack)

# struct.unpack() return a tuple
unpack = struct.unpack('4s i f l', pack)
print(unpack)
```

[Qiling](https://github.com/qilingframework) is a binary emulation framework which can emulate a portable executable, elf file or even shellcode.

`pip install qiling`

```python
from qiling import *

# Initialize emulator (x86-64 linux)
ql = Qiling([calc.exe], rootfs="dll\\examples\\rootfs\\x8664_windows")

# Start emulation
ql.run()
```

[Rz-pipe](https://book.rizin.re/scripting/rz-pipe.html) is a python wrapper for Rizin, an open-source disassembler which replaces Radare2.

`pip install rzpipe + https://github.com/rizinorg/rizin/releases/tag/v0.3.2`

```python
import rzpipe
pipe = rzpipe.open("calc.exe")
pipe.cmd('aa')

print(pipe.cmd("afl"))
print(pipe.cmdj("aflj"))
print(pipe.cmdj("ij").core.format) # shows file format

pipe.quit()
```
There is also a nice accompanying resource of "[jupyter-collections](https://jupyter.securitybreak.io)" whit code examples and more.